// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: copybook_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_copybook_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_copybook_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_copybook_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_copybook_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_copybook_5fservice_2eproto;
namespace copybook {
namespace transport {
class ConvertRequest;
struct ConvertRequestDefaultTypeInternal;
extern ConvertRequestDefaultTypeInternal _ConvertRequest_default_instance_;
class ConvertResponse;
struct ConvertResponseDefaultTypeInternal;
extern ConvertResponseDefaultTypeInternal _ConvertResponse_default_instance_;
class FieldDescriptor;
struct FieldDescriptorDefaultTypeInternal;
extern FieldDescriptorDefaultTypeInternal _FieldDescriptor_default_instance_;
class FieldValue;
struct FieldValueDefaultTypeInternal;
extern FieldValueDefaultTypeInternal _FieldValue_default_instance_;
class GetFieldsRequest;
struct GetFieldsRequestDefaultTypeInternal;
extern GetFieldsRequestDefaultTypeInternal _GetFieldsRequest_default_instance_;
class GetFieldsResponse;
struct GetFieldsResponseDefaultTypeInternal;
extern GetFieldsResponseDefaultTypeInternal _GetFieldsResponse_default_instance_;
class ListSchemasRequest;
struct ListSchemasRequestDefaultTypeInternal;
extern ListSchemasRequestDefaultTypeInternal _ListSchemasRequest_default_instance_;
class ListSchemasResponse;
struct ListSchemasResponseDefaultTypeInternal;
extern ListSchemasResponseDefaultTypeInternal _ListSchemasResponse_default_instance_;
class RecordMessage;
struct RecordMessageDefaultTypeInternal;
extern RecordMessageDefaultTypeInternal _RecordMessage_default_instance_;
class RecordPayload;
struct RecordPayloadDefaultTypeInternal;
extern RecordPayloadDefaultTypeInternal _RecordPayload_default_instance_;
class RecordSchema;
struct RecordSchemaDefaultTypeInternal;
extern RecordSchemaDefaultTypeInternal _RecordSchema_default_instance_;
class SchemaRequest;
struct SchemaRequestDefaultTypeInternal;
extern SchemaRequestDefaultTypeInternal _SchemaRequest_default_instance_;
class SchemaResponse;
struct SchemaResponseDefaultTypeInternal;
extern SchemaResponseDefaultTypeInternal _SchemaResponse_default_instance_;
class SendRequest;
struct SendRequestDefaultTypeInternal;
extern SendRequestDefaultTypeInternal _SendRequest_default_instance_;
class SendResponse;
struct SendResponseDefaultTypeInternal;
extern SendResponseDefaultTypeInternal _SendResponse_default_instance_;
class SetFieldsRequest;
struct SetFieldsRequestDefaultTypeInternal;
extern SetFieldsRequestDefaultTypeInternal _SetFieldsRequest_default_instance_;
class SetFieldsResponse;
struct SetFieldsResponseDefaultTypeInternal;
extern SetFieldsResponseDefaultTypeInternal _SetFieldsResponse_default_instance_;
}  // namespace transport
}  // namespace copybook
PROTOBUF_NAMESPACE_OPEN
template<> ::copybook::transport::ConvertRequest* Arena::CreateMaybeMessage<::copybook::transport::ConvertRequest>(Arena*);
template<> ::copybook::transport::ConvertResponse* Arena::CreateMaybeMessage<::copybook::transport::ConvertResponse>(Arena*);
template<> ::copybook::transport::FieldDescriptor* Arena::CreateMaybeMessage<::copybook::transport::FieldDescriptor>(Arena*);
template<> ::copybook::transport::FieldValue* Arena::CreateMaybeMessage<::copybook::transport::FieldValue>(Arena*);
template<> ::copybook::transport::GetFieldsRequest* Arena::CreateMaybeMessage<::copybook::transport::GetFieldsRequest>(Arena*);
template<> ::copybook::transport::GetFieldsResponse* Arena::CreateMaybeMessage<::copybook::transport::GetFieldsResponse>(Arena*);
template<> ::copybook::transport::ListSchemasRequest* Arena::CreateMaybeMessage<::copybook::transport::ListSchemasRequest>(Arena*);
template<> ::copybook::transport::ListSchemasResponse* Arena::CreateMaybeMessage<::copybook::transport::ListSchemasResponse>(Arena*);
template<> ::copybook::transport::RecordMessage* Arena::CreateMaybeMessage<::copybook::transport::RecordMessage>(Arena*);
template<> ::copybook::transport::RecordPayload* Arena::CreateMaybeMessage<::copybook::transport::RecordPayload>(Arena*);
template<> ::copybook::transport::RecordSchema* Arena::CreateMaybeMessage<::copybook::transport::RecordSchema>(Arena*);
template<> ::copybook::transport::SchemaRequest* Arena::CreateMaybeMessage<::copybook::transport::SchemaRequest>(Arena*);
template<> ::copybook::transport::SchemaResponse* Arena::CreateMaybeMessage<::copybook::transport::SchemaResponse>(Arena*);
template<> ::copybook::transport::SendRequest* Arena::CreateMaybeMessage<::copybook::transport::SendRequest>(Arena*);
template<> ::copybook::transport::SendResponse* Arena::CreateMaybeMessage<::copybook::transport::SendResponse>(Arena*);
template<> ::copybook::transport::SetFieldsRequest* Arena::CreateMaybeMessage<::copybook::transport::SetFieldsRequest>(Arena*);
template<> ::copybook::transport::SetFieldsResponse* Arena::CreateMaybeMessage<::copybook::transport::SetFieldsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace copybook {
namespace transport {

// ===================================================================

class FieldValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.FieldValue) */ {
 public:
  inline FieldValue() : FieldValue(nullptr) {}
  ~FieldValue() override;
  explicit PROTOBUF_CONSTEXPR FieldValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldValue(const FieldValue& from);
  FieldValue(FieldValue&& from) noexcept
    : FieldValue() {
    *this = ::std::move(from);
  }

  inline FieldValue& operator=(const FieldValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldValue& operator=(FieldValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldValue* internal_default_instance() {
    return reinterpret_cast<const FieldValue*>(
               &_FieldValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FieldValue& a, FieldValue& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldValue& from) {
    FieldValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.FieldValue";
  }
  protected:
  explicit FieldValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:copybook.transport.FieldValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RecordPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.RecordPayload) */ {
 public:
  inline RecordPayload() : RecordPayload(nullptr) {}
  ~RecordPayload() override;
  explicit PROTOBUF_CONSTEXPR RecordPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordPayload(const RecordPayload& from);
  RecordPayload(RecordPayload&& from) noexcept
    : RecordPayload() {
    *this = ::std::move(from);
  }

  inline RecordPayload& operator=(const RecordPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordPayload& operator=(RecordPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordPayload* internal_default_instance() {
    return reinterpret_cast<const RecordPayload*>(
               &_RecordPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RecordPayload& a, RecordPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordPayload& from) {
    RecordPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.RecordPayload";
  }
  protected:
  explicit RecordPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordNameFieldNumber = 1,
    kRawBufferFieldNumber = 2,
    kBufferSizeFieldNumber = 3,
  };
  // string record_name = 1;
  void clear_record_name();
  const std::string& record_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_record_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_record_name();
  PROTOBUF_NODISCARD std::string* release_record_name();
  void set_allocated_record_name(std::string* record_name);
  private:
  const std::string& _internal_record_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_record_name(const std::string& value);
  std::string* _internal_mutable_record_name();
  public:

  // bytes raw_buffer = 2;
  void clear_raw_buffer();
  const std::string& raw_buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_buffer();
  PROTOBUF_NODISCARD std::string* release_raw_buffer();
  void set_allocated_raw_buffer(std::string* raw_buffer);
  private:
  const std::string& _internal_raw_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_buffer(const std::string& value);
  std::string* _internal_mutable_raw_buffer();
  public:

  // int32 buffer_size = 3;
  void clear_buffer_size();
  int32_t buffer_size() const;
  void set_buffer_size(int32_t value);
  private:
  int32_t _internal_buffer_size() const;
  void _internal_set_buffer_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:copybook.transport.RecordPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr record_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_buffer_;
    int32_t buffer_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RecordMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.RecordMessage) */ {
 public:
  inline RecordMessage() : RecordMessage(nullptr) {}
  ~RecordMessage() override;
  explicit PROTOBUF_CONSTEXPR RecordMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordMessage(const RecordMessage& from);
  RecordMessage(RecordMessage&& from) noexcept
    : RecordMessage() {
    *this = ::std::move(from);
  }

  inline RecordMessage& operator=(const RecordMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordMessage& operator=(RecordMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordMessage* internal_default_instance() {
    return reinterpret_cast<const RecordMessage*>(
               &_RecordMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RecordMessage& a, RecordMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordMessage& from) {
    RecordMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.RecordMessage";
  }
  protected:
  explicit RecordMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kRecordNameFieldNumber = 1,
  };
  // repeated .copybook.transport.FieldValue fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::copybook::transport::FieldValue* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldValue >*
      mutable_fields();
  private:
  const ::copybook::transport::FieldValue& _internal_fields(int index) const;
  ::copybook::transport::FieldValue* _internal_add_fields();
  public:
  const ::copybook::transport::FieldValue& fields(int index) const;
  ::copybook::transport::FieldValue* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldValue >&
      fields() const;

  // string record_name = 1;
  void clear_record_name();
  const std::string& record_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_record_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_record_name();
  PROTOBUF_NODISCARD std::string* release_record_name();
  void set_allocated_record_name(std::string* record_name);
  private:
  const std::string& _internal_record_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_record_name(const std::string& value);
  std::string* _internal_mutable_record_name();
  public:

  // @@protoc_insertion_point(class_scope:copybook.transport.RecordMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldValue > fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr record_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class FieldDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.FieldDescriptor) */ {
 public:
  inline FieldDescriptor() : FieldDescriptor(nullptr) {}
  ~FieldDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FieldDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldDescriptor(const FieldDescriptor& from);
  FieldDescriptor(FieldDescriptor&& from) noexcept
    : FieldDescriptor() {
    *this = ::std::move(from);
  }

  inline FieldDescriptor& operator=(const FieldDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldDescriptor& operator=(FieldDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldDescriptor* internal_default_instance() {
    return reinterpret_cast<const FieldDescriptor*>(
               &_FieldDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FieldDescriptor& a, FieldDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldDescriptor& from) {
    FieldDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.FieldDescriptor";
  }
  protected:
  explicit FieldDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 10,
    kNameFieldNumber = 1,
    kCobolNameFieldNumber = 2,
    kPicClauseFieldNumber = 3,
    kTypeFieldNumber = 4,
    kOffsetFieldNumber = 5,
    kSizeFieldNumber = 6,
    kDecimalPositionsFieldNumber = 7,
    kIsGroupFieldNumber = 8,
    kIsFillerFieldNumber = 9,
  };
  // repeated .copybook.transport.FieldDescriptor children = 10;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::copybook::transport::FieldDescriptor* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor >*
      mutable_children();
  private:
  const ::copybook::transport::FieldDescriptor& _internal_children(int index) const;
  ::copybook::transport::FieldDescriptor* _internal_add_children();
  public:
  const ::copybook::transport::FieldDescriptor& children(int index) const;
  ::copybook::transport::FieldDescriptor* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor >&
      children() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string cobol_name = 2;
  void clear_cobol_name();
  const std::string& cobol_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cobol_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cobol_name();
  PROTOBUF_NODISCARD std::string* release_cobol_name();
  void set_allocated_cobol_name(std::string* cobol_name);
  private:
  const std::string& _internal_cobol_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cobol_name(const std::string& value);
  std::string* _internal_mutable_cobol_name();
  public:

  // string pic_clause = 3;
  void clear_pic_clause();
  const std::string& pic_clause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pic_clause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pic_clause();
  PROTOBUF_NODISCARD std::string* release_pic_clause();
  void set_allocated_pic_clause(std::string* pic_clause);
  private:
  const std::string& _internal_pic_clause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pic_clause(const std::string& value);
  std::string* _internal_mutable_pic_clause();
  public:

  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // int32 offset = 5;
  void clear_offset();
  int32_t offset() const;
  void set_offset(int32_t value);
  private:
  int32_t _internal_offset() const;
  void _internal_set_offset(int32_t value);
  public:

  // int32 size = 6;
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // int32 decimal_positions = 7;
  void clear_decimal_positions();
  int32_t decimal_positions() const;
  void set_decimal_positions(int32_t value);
  private:
  int32_t _internal_decimal_positions() const;
  void _internal_set_decimal_positions(int32_t value);
  public:

  // bool is_group = 8;
  void clear_is_group();
  bool is_group() const;
  void set_is_group(bool value);
  private:
  bool _internal_is_group() const;
  void _internal_set_is_group(bool value);
  public:

  // bool is_filler = 9;
  void clear_is_filler();
  bool is_filler() const;
  void set_is_filler(bool value);
  private:
  bool _internal_is_filler() const;
  void _internal_set_is_filler(bool value);
  public:

  // @@protoc_insertion_point(class_scope:copybook.transport.FieldDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor > children_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cobol_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pic_clause_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    int32_t offset_;
    int32_t size_;
    int32_t decimal_positions_;
    bool is_group_;
    bool is_filler_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RecordSchema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.RecordSchema) */ {
 public:
  inline RecordSchema() : RecordSchema(nullptr) {}
  ~RecordSchema() override;
  explicit PROTOBUF_CONSTEXPR RecordSchema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordSchema(const RecordSchema& from);
  RecordSchema(RecordSchema&& from) noexcept
    : RecordSchema() {
    *this = ::std::move(from);
  }

  inline RecordSchema& operator=(const RecordSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordSchema& operator=(RecordSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordSchema* internal_default_instance() {
    return reinterpret_cast<const RecordSchema*>(
               &_RecordSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RecordSchema& a, RecordSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordSchema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordSchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordSchema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordSchema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordSchema& from) {
    RecordSchema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordSchema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.RecordSchema";
  }
  protected:
  explicit RecordSchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 4,
    kRecordNameFieldNumber = 1,
    kCppClassNameFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .copybook.transport.FieldDescriptor fields = 4;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::copybook::transport::FieldDescriptor* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor >*
      mutable_fields();
  private:
  const ::copybook::transport::FieldDescriptor& _internal_fields(int index) const;
  ::copybook::transport::FieldDescriptor* _internal_add_fields();
  public:
  const ::copybook::transport::FieldDescriptor& fields(int index) const;
  ::copybook::transport::FieldDescriptor* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor >&
      fields() const;

  // string record_name = 1;
  void clear_record_name();
  const std::string& record_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_record_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_record_name();
  PROTOBUF_NODISCARD std::string* release_record_name();
  void set_allocated_record_name(std::string* record_name);
  private:
  const std::string& _internal_record_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_record_name(const std::string& value);
  std::string* _internal_mutable_record_name();
  public:

  // string cpp_class_name = 2;
  void clear_cpp_class_name();
  const std::string& cpp_class_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cpp_class_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cpp_class_name();
  PROTOBUF_NODISCARD std::string* release_cpp_class_name();
  void set_allocated_cpp_class_name(std::string* cpp_class_name);
  private:
  const std::string& _internal_cpp_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpp_class_name(const std::string& value);
  std::string* _internal_mutable_cpp_class_name();
  public:

  // int32 total_size = 3;
  void clear_total_size();
  int32_t total_size() const;
  void set_total_size(int32_t value);
  private:
  int32_t _internal_total_size() const;
  void _internal_set_total_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:copybook.transport.RecordSchema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor > fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr record_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpp_class_name_;
    int32_t total_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.SendRequest) */ {
 public:
  inline SendRequest() : SendRequest(nullptr) {}
  ~SendRequest() override;
  explicit PROTOBUF_CONSTEXPR SendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendRequest(const SendRequest& from);
  SendRequest(SendRequest&& from) noexcept
    : SendRequest() {
    *this = ::std::move(from);
  }

  inline SendRequest& operator=(const SendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendRequest& operator=(SendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendRequest* internal_default_instance() {
    return reinterpret_cast<const SendRequest*>(
               &_SendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SendRequest& a, SendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendRequest& from) {
    SendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.SendRequest";
  }
  protected:
  explicit SendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // .copybook.transport.RecordPayload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::copybook::transport::RecordPayload& payload() const;
  PROTOBUF_NODISCARD ::copybook::transport::RecordPayload* release_payload();
  ::copybook::transport::RecordPayload* mutable_payload();
  void set_allocated_payload(::copybook::transport::RecordPayload* payload);
  private:
  const ::copybook::transport::RecordPayload& _internal_payload() const;
  ::copybook::transport::RecordPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::copybook::transport::RecordPayload* payload);
  ::copybook::transport::RecordPayload* unsafe_arena_release_payload();

  // @@protoc_insertion_point(class_scope:copybook.transport.SendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::copybook::transport::RecordPayload* payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.SendResponse) */ {
 public:
  inline SendResponse() : SendResponse(nullptr) {}
  ~SendResponse() override;
  explicit PROTOBUF_CONSTEXPR SendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendResponse(const SendResponse& from);
  SendResponse(SendResponse&& from) noexcept
    : SendResponse() {
    *this = ::std::move(from);
  }

  inline SendResponse& operator=(const SendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendResponse& operator=(SendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendResponse* internal_default_instance() {
    return reinterpret_cast<const SendResponse*>(
               &_SendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SendResponse& a, SendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendResponse& from) {
    SendResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.SendResponse";
  }
  protected:
  explicit SendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:copybook.transport.SendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetFieldsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.GetFieldsRequest) */ {
 public:
  inline GetFieldsRequest() : GetFieldsRequest(nullptr) {}
  ~GetFieldsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetFieldsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFieldsRequest(const GetFieldsRequest& from);
  GetFieldsRequest(GetFieldsRequest&& from) noexcept
    : GetFieldsRequest() {
    *this = ::std::move(from);
  }

  inline GetFieldsRequest& operator=(const GetFieldsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFieldsRequest& operator=(GetFieldsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFieldsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFieldsRequest* internal_default_instance() {
    return reinterpret_cast<const GetFieldsRequest*>(
               &_GetFieldsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetFieldsRequest& a, GetFieldsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFieldsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFieldsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFieldsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFieldsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFieldsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFieldsRequest& from) {
    GetFieldsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFieldsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.GetFieldsRequest";
  }
  protected:
  explicit GetFieldsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // .copybook.transport.RecordPayload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::copybook::transport::RecordPayload& payload() const;
  PROTOBUF_NODISCARD ::copybook::transport::RecordPayload* release_payload();
  ::copybook::transport::RecordPayload* mutable_payload();
  void set_allocated_payload(::copybook::transport::RecordPayload* payload);
  private:
  const ::copybook::transport::RecordPayload& _internal_payload() const;
  ::copybook::transport::RecordPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::copybook::transport::RecordPayload* payload);
  ::copybook::transport::RecordPayload* unsafe_arena_release_payload();

  // @@protoc_insertion_point(class_scope:copybook.transport.GetFieldsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::copybook::transport::RecordPayload* payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetFieldsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.GetFieldsResponse) */ {
 public:
  inline GetFieldsResponse() : GetFieldsResponse(nullptr) {}
  ~GetFieldsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetFieldsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFieldsResponse(const GetFieldsResponse& from);
  GetFieldsResponse(GetFieldsResponse&& from) noexcept
    : GetFieldsResponse() {
    *this = ::std::move(from);
  }

  inline GetFieldsResponse& operator=(const GetFieldsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFieldsResponse& operator=(GetFieldsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFieldsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFieldsResponse* internal_default_instance() {
    return reinterpret_cast<const GetFieldsResponse*>(
               &_GetFieldsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetFieldsResponse& a, GetFieldsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFieldsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFieldsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFieldsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFieldsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFieldsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFieldsResponse& from) {
    GetFieldsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFieldsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.GetFieldsResponse";
  }
  protected:
  explicit GetFieldsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 1,
  };
  // .copybook.transport.RecordMessage record = 1;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::copybook::transport::RecordMessage& record() const;
  PROTOBUF_NODISCARD ::copybook::transport::RecordMessage* release_record();
  ::copybook::transport::RecordMessage* mutable_record();
  void set_allocated_record(::copybook::transport::RecordMessage* record);
  private:
  const ::copybook::transport::RecordMessage& _internal_record() const;
  ::copybook::transport::RecordMessage* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::copybook::transport::RecordMessage* record);
  ::copybook::transport::RecordMessage* unsafe_arena_release_record();

  // @@protoc_insertion_point(class_scope:copybook.transport.GetFieldsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::copybook::transport::RecordMessage* record_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SetFieldsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.SetFieldsRequest) */ {
 public:
  inline SetFieldsRequest() : SetFieldsRequest(nullptr) {}
  ~SetFieldsRequest() override;
  explicit PROTOBUF_CONSTEXPR SetFieldsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFieldsRequest(const SetFieldsRequest& from);
  SetFieldsRequest(SetFieldsRequest&& from) noexcept
    : SetFieldsRequest() {
    *this = ::std::move(from);
  }

  inline SetFieldsRequest& operator=(const SetFieldsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFieldsRequest& operator=(SetFieldsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFieldsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFieldsRequest* internal_default_instance() {
    return reinterpret_cast<const SetFieldsRequest*>(
               &_SetFieldsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SetFieldsRequest& a, SetFieldsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFieldsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFieldsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFieldsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFieldsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFieldsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetFieldsRequest& from) {
    SetFieldsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFieldsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.SetFieldsRequest";
  }
  protected:
  explicit SetFieldsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 1,
    kBufferSizeFieldNumber = 2,
  };
  // .copybook.transport.RecordMessage record = 1;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::copybook::transport::RecordMessage& record() const;
  PROTOBUF_NODISCARD ::copybook::transport::RecordMessage* release_record();
  ::copybook::transport::RecordMessage* mutable_record();
  void set_allocated_record(::copybook::transport::RecordMessage* record);
  private:
  const ::copybook::transport::RecordMessage& _internal_record() const;
  ::copybook::transport::RecordMessage* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::copybook::transport::RecordMessage* record);
  ::copybook::transport::RecordMessage* unsafe_arena_release_record();

  // int32 buffer_size = 2;
  void clear_buffer_size();
  int32_t buffer_size() const;
  void set_buffer_size(int32_t value);
  private:
  int32_t _internal_buffer_size() const;
  void _internal_set_buffer_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:copybook.transport.SetFieldsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::copybook::transport::RecordMessage* record_;
    int32_t buffer_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SetFieldsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.SetFieldsResponse) */ {
 public:
  inline SetFieldsResponse() : SetFieldsResponse(nullptr) {}
  ~SetFieldsResponse() override;
  explicit PROTOBUF_CONSTEXPR SetFieldsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFieldsResponse(const SetFieldsResponse& from);
  SetFieldsResponse(SetFieldsResponse&& from) noexcept
    : SetFieldsResponse() {
    *this = ::std::move(from);
  }

  inline SetFieldsResponse& operator=(const SetFieldsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFieldsResponse& operator=(SetFieldsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFieldsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFieldsResponse* internal_default_instance() {
    return reinterpret_cast<const SetFieldsResponse*>(
               &_SetFieldsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetFieldsResponse& a, SetFieldsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFieldsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFieldsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFieldsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFieldsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFieldsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetFieldsResponse& from) {
    SetFieldsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFieldsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.SetFieldsResponse";
  }
  protected:
  explicit SetFieldsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // .copybook.transport.RecordPayload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::copybook::transport::RecordPayload& payload() const;
  PROTOBUF_NODISCARD ::copybook::transport::RecordPayload* release_payload();
  ::copybook::transport::RecordPayload* mutable_payload();
  void set_allocated_payload(::copybook::transport::RecordPayload* payload);
  private:
  const ::copybook::transport::RecordPayload& _internal_payload() const;
  ::copybook::transport::RecordPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::copybook::transport::RecordPayload* payload);
  ::copybook::transport::RecordPayload* unsafe_arena_release_payload();

  // @@protoc_insertion_point(class_scope:copybook.transport.SetFieldsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::copybook::transport::RecordPayload* payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SchemaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.SchemaRequest) */ {
 public:
  inline SchemaRequest() : SchemaRequest(nullptr) {}
  ~SchemaRequest() override;
  explicit PROTOBUF_CONSTEXPR SchemaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaRequest(const SchemaRequest& from);
  SchemaRequest(SchemaRequest&& from) noexcept
    : SchemaRequest() {
    *this = ::std::move(from);
  }

  inline SchemaRequest& operator=(const SchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaRequest& operator=(SchemaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaRequest* internal_default_instance() {
    return reinterpret_cast<const SchemaRequest*>(
               &_SchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SchemaRequest& a, SchemaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchemaRequest& from) {
    SchemaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.SchemaRequest";
  }
  protected:
  explicit SchemaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordNameFieldNumber = 1,
  };
  // string record_name = 1;
  void clear_record_name();
  const std::string& record_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_record_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_record_name();
  PROTOBUF_NODISCARD std::string* release_record_name();
  void set_allocated_record_name(std::string* record_name);
  private:
  const std::string& _internal_record_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_record_name(const std::string& value);
  std::string* _internal_mutable_record_name();
  public:

  // @@protoc_insertion_point(class_scope:copybook.transport.SchemaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr record_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SchemaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.SchemaResponse) */ {
 public:
  inline SchemaResponse() : SchemaResponse(nullptr) {}
  ~SchemaResponse() override;
  explicit PROTOBUF_CONSTEXPR SchemaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaResponse(const SchemaResponse& from);
  SchemaResponse(SchemaResponse&& from) noexcept
    : SchemaResponse() {
    *this = ::std::move(from);
  }

  inline SchemaResponse& operator=(const SchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaResponse& operator=(SchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaResponse* internal_default_instance() {
    return reinterpret_cast<const SchemaResponse*>(
               &_SchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SchemaResponse& a, SchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchemaResponse& from) {
    SchemaResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.SchemaResponse";
  }
  protected:
  explicit SchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 1,
  };
  // .copybook.transport.RecordSchema schema = 1;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::copybook::transport::RecordSchema& schema() const;
  PROTOBUF_NODISCARD ::copybook::transport::RecordSchema* release_schema();
  ::copybook::transport::RecordSchema* mutable_schema();
  void set_allocated_schema(::copybook::transport::RecordSchema* schema);
  private:
  const ::copybook::transport::RecordSchema& _internal_schema() const;
  ::copybook::transport::RecordSchema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::copybook::transport::RecordSchema* schema);
  ::copybook::transport::RecordSchema* unsafe_arena_release_schema();

  // @@protoc_insertion_point(class_scope:copybook.transport.SchemaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::copybook::transport::RecordSchema* schema_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListSchemasRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:copybook.transport.ListSchemasRequest) */ {
 public:
  inline ListSchemasRequest() : ListSchemasRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListSchemasRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSchemasRequest(const ListSchemasRequest& from);
  ListSchemasRequest(ListSchemasRequest&& from) noexcept
    : ListSchemasRequest() {
    *this = ::std::move(from);
  }

  inline ListSchemasRequest& operator=(const ListSchemasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSchemasRequest& operator=(ListSchemasRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSchemasRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSchemasRequest* internal_default_instance() {
    return reinterpret_cast<const ListSchemasRequest*>(
               &_ListSchemasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListSchemasRequest& a, ListSchemasRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSchemasRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSchemasRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSchemasRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSchemasRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListSchemasRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListSchemasRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.ListSchemasRequest";
  }
  protected:
  explicit ListSchemasRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:copybook.transport.ListSchemasRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListSchemasResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.ListSchemasResponse) */ {
 public:
  inline ListSchemasResponse() : ListSchemasResponse(nullptr) {}
  ~ListSchemasResponse() override;
  explicit PROTOBUF_CONSTEXPR ListSchemasResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSchemasResponse(const ListSchemasResponse& from);
  ListSchemasResponse(ListSchemasResponse&& from) noexcept
    : ListSchemasResponse() {
    *this = ::std::move(from);
  }

  inline ListSchemasResponse& operator=(const ListSchemasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSchemasResponse& operator=(ListSchemasResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSchemasResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSchemasResponse* internal_default_instance() {
    return reinterpret_cast<const ListSchemasResponse*>(
               &_ListSchemasResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListSchemasResponse& a, ListSchemasResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSchemasResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSchemasResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSchemasResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSchemasResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSchemasResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListSchemasResponse& from) {
    ListSchemasResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSchemasResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.ListSchemasResponse";
  }
  protected:
  explicit ListSchemasResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemasFieldNumber = 1,
  };
  // repeated .copybook.transport.RecordSchema schemas = 1;
  int schemas_size() const;
  private:
  int _internal_schemas_size() const;
  public:
  void clear_schemas();
  ::copybook::transport::RecordSchema* mutable_schemas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::RecordSchema >*
      mutable_schemas();
  private:
  const ::copybook::transport::RecordSchema& _internal_schemas(int index) const;
  ::copybook::transport::RecordSchema* _internal_add_schemas();
  public:
  const ::copybook::transport::RecordSchema& schemas(int index) const;
  ::copybook::transport::RecordSchema* add_schemas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::RecordSchema >&
      schemas() const;

  // @@protoc_insertion_point(class_scope:copybook.transport.ListSchemasResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::RecordSchema > schemas_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ConvertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.ConvertRequest) */ {
 public:
  inline ConvertRequest() : ConvertRequest(nullptr) {}
  ~ConvertRequest() override;
  explicit PROTOBUF_CONSTEXPR ConvertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConvertRequest(const ConvertRequest& from);
  ConvertRequest(ConvertRequest&& from) noexcept
    : ConvertRequest() {
    *this = ::std::move(from);
  }

  inline ConvertRequest& operator=(const ConvertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvertRequest& operator=(ConvertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvertRequest& default_instance() {
    return *internal_default_instance();
  }
  enum SourceCase {
    kPayload = 2,
    kFormatData = 3,
    SOURCE_NOT_SET = 0,
  };

  static inline const ConvertRequest* internal_default_instance() {
    return reinterpret_cast<const ConvertRequest*>(
               &_ConvertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ConvertRequest& a, ConvertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConvertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConvertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConvertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConvertRequest& from) {
    ConvertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.ConvertRequest";
  }
  protected:
  explicit ConvertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kRecordNameFieldNumber = 4,
    kPayloadFieldNumber = 2,
    kFormatDataFieldNumber = 3,
  };
  // string format = 1;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // string record_name = 4;
  void clear_record_name();
  const std::string& record_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_record_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_record_name();
  PROTOBUF_NODISCARD std::string* release_record_name();
  void set_allocated_record_name(std::string* record_name);
  private:
  const std::string& _internal_record_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_record_name(const std::string& value);
  std::string* _internal_mutable_record_name();
  public:

  // .copybook.transport.RecordPayload payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::copybook::transport::RecordPayload& payload() const;
  PROTOBUF_NODISCARD ::copybook::transport::RecordPayload* release_payload();
  ::copybook::transport::RecordPayload* mutable_payload();
  void set_allocated_payload(::copybook::transport::RecordPayload* payload);
  private:
  const ::copybook::transport::RecordPayload& _internal_payload() const;
  ::copybook::transport::RecordPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::copybook::transport::RecordPayload* payload);
  ::copybook::transport::RecordPayload* unsafe_arena_release_payload();

  // string format_data = 3;
  bool has_format_data() const;
  private:
  bool _internal_has_format_data() const;
  public:
  void clear_format_data();
  const std::string& format_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format_data();
  PROTOBUF_NODISCARD std::string* release_format_data();
  void set_allocated_format_data(std::string* format_data);
  private:
  const std::string& _internal_format_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format_data(const std::string& value);
  std::string* _internal_mutable_format_data();
  public:

  void clear_source();
  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:copybook.transport.ConvertRequest)
 private:
  class _Internal;
  void set_has_payload();
  void set_has_format_data();

  inline bool has_source() const;
  inline void clear_has_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr record_name_;
    union SourceUnion {
      constexpr SourceUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::copybook::transport::RecordPayload* payload_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_data_;
    } source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ConvertResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:copybook.transport.ConvertResponse) */ {
 public:
  inline ConvertResponse() : ConvertResponse(nullptr) {}
  ~ConvertResponse() override;
  explicit PROTOBUF_CONSTEXPR ConvertResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConvertResponse(const ConvertResponse& from);
  ConvertResponse(ConvertResponse&& from) noexcept
    : ConvertResponse() {
    *this = ::std::move(from);
  }

  inline ConvertResponse& operator=(const ConvertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvertResponse& operator=(ConvertResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvertResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kFormatData = 1,
    kPayload = 2,
    RESULT_NOT_SET = 0,
  };

  static inline const ConvertResponse* internal_default_instance() {
    return reinterpret_cast<const ConvertResponse*>(
               &_ConvertResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ConvertResponse& a, ConvertResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConvertResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvertResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvertResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConvertResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConvertResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConvertResponse& from) {
    ConvertResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvertResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "copybook.transport.ConvertResponse";
  }
  protected:
  explicit ConvertResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatDataFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // string format_data = 1;
  bool has_format_data() const;
  private:
  bool _internal_has_format_data() const;
  public:
  void clear_format_data();
  const std::string& format_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format_data();
  PROTOBUF_NODISCARD std::string* release_format_data();
  void set_allocated_format_data(std::string* format_data);
  private:
  const std::string& _internal_format_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format_data(const std::string& value);
  std::string* _internal_mutable_format_data();
  public:

  // .copybook.transport.RecordPayload payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::copybook::transport::RecordPayload& payload() const;
  PROTOBUF_NODISCARD ::copybook::transport::RecordPayload* release_payload();
  ::copybook::transport::RecordPayload* mutable_payload();
  void set_allocated_payload(::copybook::transport::RecordPayload* payload);
  private:
  const ::copybook::transport::RecordPayload& _internal_payload() const;
  ::copybook::transport::RecordPayload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::copybook::transport::RecordPayload* payload);
  ::copybook::transport::RecordPayload* unsafe_arena_release_payload();

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:copybook.transport.ConvertResponse)
 private:
  class _Internal;
  void set_has_format_data();
  void set_has_payload();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_data_;
      ::copybook::transport::RecordPayload* payload_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_copybook_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FieldValue

// string name = 1;
inline void FieldValue::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FieldValue::name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldValue.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldValue::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.FieldValue.name)
}
inline std::string* FieldValue::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.FieldValue.name)
  return _s;
}
inline const std::string& FieldValue::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FieldValue::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldValue::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldValue::release_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.FieldValue.name)
  return _impl_.name_.Release();
}
inline void FieldValue::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.FieldValue.name)
}

// string value = 2;
inline void FieldValue::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& FieldValue::value() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldValue.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldValue::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.FieldValue.value)
}
inline std::string* FieldValue::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:copybook.transport.FieldValue.value)
  return _s;
}
inline const std::string& FieldValue::_internal_value() const {
  return _impl_.value_.Get();
}
inline void FieldValue::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldValue::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldValue::release_value() {
  // @@protoc_insertion_point(field_release:copybook.transport.FieldValue.value)
  return _impl_.value_.Release();
}
inline void FieldValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.FieldValue.value)
}

// -------------------------------------------------------------------

// RecordPayload

// string record_name = 1;
inline void RecordPayload::clear_record_name() {
  _impl_.record_name_.ClearToEmpty();
}
inline const std::string& RecordPayload::record_name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordPayload.record_name)
  return _internal_record_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordPayload::set_record_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.record_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.RecordPayload.record_name)
}
inline std::string* RecordPayload::mutable_record_name() {
  std::string* _s = _internal_mutable_record_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.RecordPayload.record_name)
  return _s;
}
inline const std::string& RecordPayload::_internal_record_name() const {
  return _impl_.record_name_.Get();
}
inline void RecordPayload::_internal_set_record_name(const std::string& value) {
  
  _impl_.record_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordPayload::_internal_mutable_record_name() {
  
  return _impl_.record_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordPayload::release_record_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.RecordPayload.record_name)
  return _impl_.record_name_.Release();
}
inline void RecordPayload::set_allocated_record_name(std::string* record_name) {
  if (record_name != nullptr) {
    
  } else {
    
  }
  _impl_.record_name_.SetAllocated(record_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.record_name_.IsDefault()) {
    _impl_.record_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.RecordPayload.record_name)
}

// bytes raw_buffer = 2;
inline void RecordPayload::clear_raw_buffer() {
  _impl_.raw_buffer_.ClearToEmpty();
}
inline const std::string& RecordPayload::raw_buffer() const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordPayload.raw_buffer)
  return _internal_raw_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordPayload::set_raw_buffer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.raw_buffer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.RecordPayload.raw_buffer)
}
inline std::string* RecordPayload::mutable_raw_buffer() {
  std::string* _s = _internal_mutable_raw_buffer();
  // @@protoc_insertion_point(field_mutable:copybook.transport.RecordPayload.raw_buffer)
  return _s;
}
inline const std::string& RecordPayload::_internal_raw_buffer() const {
  return _impl_.raw_buffer_.Get();
}
inline void RecordPayload::_internal_set_raw_buffer(const std::string& value) {
  
  _impl_.raw_buffer_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordPayload::_internal_mutable_raw_buffer() {
  
  return _impl_.raw_buffer_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordPayload::release_raw_buffer() {
  // @@protoc_insertion_point(field_release:copybook.transport.RecordPayload.raw_buffer)
  return _impl_.raw_buffer_.Release();
}
inline void RecordPayload::set_allocated_raw_buffer(std::string* raw_buffer) {
  if (raw_buffer != nullptr) {
    
  } else {
    
  }
  _impl_.raw_buffer_.SetAllocated(raw_buffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.raw_buffer_.IsDefault()) {
    _impl_.raw_buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.RecordPayload.raw_buffer)
}

// int32 buffer_size = 3;
inline void RecordPayload::clear_buffer_size() {
  _impl_.buffer_size_ = 0;
}
inline int32_t RecordPayload::_internal_buffer_size() const {
  return _impl_.buffer_size_;
}
inline int32_t RecordPayload::buffer_size() const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordPayload.buffer_size)
  return _internal_buffer_size();
}
inline void RecordPayload::_internal_set_buffer_size(int32_t value) {
  
  _impl_.buffer_size_ = value;
}
inline void RecordPayload::set_buffer_size(int32_t value) {
  _internal_set_buffer_size(value);
  // @@protoc_insertion_point(field_set:copybook.transport.RecordPayload.buffer_size)
}

// -------------------------------------------------------------------

// RecordMessage

// string record_name = 1;
inline void RecordMessage::clear_record_name() {
  _impl_.record_name_.ClearToEmpty();
}
inline const std::string& RecordMessage::record_name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordMessage.record_name)
  return _internal_record_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordMessage::set_record_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.record_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.RecordMessage.record_name)
}
inline std::string* RecordMessage::mutable_record_name() {
  std::string* _s = _internal_mutable_record_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.RecordMessage.record_name)
  return _s;
}
inline const std::string& RecordMessage::_internal_record_name() const {
  return _impl_.record_name_.Get();
}
inline void RecordMessage::_internal_set_record_name(const std::string& value) {
  
  _impl_.record_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordMessage::_internal_mutable_record_name() {
  
  return _impl_.record_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordMessage::release_record_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.RecordMessage.record_name)
  return _impl_.record_name_.Release();
}
inline void RecordMessage::set_allocated_record_name(std::string* record_name) {
  if (record_name != nullptr) {
    
  } else {
    
  }
  _impl_.record_name_.SetAllocated(record_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.record_name_.IsDefault()) {
    _impl_.record_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.RecordMessage.record_name)
}

// repeated .copybook.transport.FieldValue fields = 2;
inline int RecordMessage::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int RecordMessage::fields_size() const {
  return _internal_fields_size();
}
inline void RecordMessage::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::copybook::transport::FieldValue* RecordMessage::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:copybook.transport.RecordMessage.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldValue >*
RecordMessage::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:copybook.transport.RecordMessage.fields)
  return &_impl_.fields_;
}
inline const ::copybook::transport::FieldValue& RecordMessage::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::copybook::transport::FieldValue& RecordMessage::fields(int index) const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordMessage.fields)
  return _internal_fields(index);
}
inline ::copybook::transport::FieldValue* RecordMessage::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::copybook::transport::FieldValue* RecordMessage::add_fields() {
  ::copybook::transport::FieldValue* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:copybook.transport.RecordMessage.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldValue >&
RecordMessage::fields() const {
  // @@protoc_insertion_point(field_list:copybook.transport.RecordMessage.fields)
  return _impl_.fields_;
}

// -------------------------------------------------------------------

// FieldDescriptor

// string name = 1;
inline void FieldDescriptor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FieldDescriptor::name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldDescriptor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.name)
}
inline std::string* FieldDescriptor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.FieldDescriptor.name)
  return _s;
}
inline const std::string& FieldDescriptor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FieldDescriptor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldDescriptor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.FieldDescriptor.name)
  return _impl_.name_.Release();
}
inline void FieldDescriptor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.FieldDescriptor.name)
}

// string cobol_name = 2;
inline void FieldDescriptor::clear_cobol_name() {
  _impl_.cobol_name_.ClearToEmpty();
}
inline const std::string& FieldDescriptor::cobol_name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.cobol_name)
  return _internal_cobol_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldDescriptor::set_cobol_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cobol_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.cobol_name)
}
inline std::string* FieldDescriptor::mutable_cobol_name() {
  std::string* _s = _internal_mutable_cobol_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.FieldDescriptor.cobol_name)
  return _s;
}
inline const std::string& FieldDescriptor::_internal_cobol_name() const {
  return _impl_.cobol_name_.Get();
}
inline void FieldDescriptor::_internal_set_cobol_name(const std::string& value) {
  
  _impl_.cobol_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldDescriptor::_internal_mutable_cobol_name() {
  
  return _impl_.cobol_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldDescriptor::release_cobol_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.FieldDescriptor.cobol_name)
  return _impl_.cobol_name_.Release();
}
inline void FieldDescriptor::set_allocated_cobol_name(std::string* cobol_name) {
  if (cobol_name != nullptr) {
    
  } else {
    
  }
  _impl_.cobol_name_.SetAllocated(cobol_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cobol_name_.IsDefault()) {
    _impl_.cobol_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.FieldDescriptor.cobol_name)
}

// string pic_clause = 3;
inline void FieldDescriptor::clear_pic_clause() {
  _impl_.pic_clause_.ClearToEmpty();
}
inline const std::string& FieldDescriptor::pic_clause() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.pic_clause)
  return _internal_pic_clause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldDescriptor::set_pic_clause(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pic_clause_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.pic_clause)
}
inline std::string* FieldDescriptor::mutable_pic_clause() {
  std::string* _s = _internal_mutable_pic_clause();
  // @@protoc_insertion_point(field_mutable:copybook.transport.FieldDescriptor.pic_clause)
  return _s;
}
inline const std::string& FieldDescriptor::_internal_pic_clause() const {
  return _impl_.pic_clause_.Get();
}
inline void FieldDescriptor::_internal_set_pic_clause(const std::string& value) {
  
  _impl_.pic_clause_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldDescriptor::_internal_mutable_pic_clause() {
  
  return _impl_.pic_clause_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldDescriptor::release_pic_clause() {
  // @@protoc_insertion_point(field_release:copybook.transport.FieldDescriptor.pic_clause)
  return _impl_.pic_clause_.Release();
}
inline void FieldDescriptor::set_allocated_pic_clause(std::string* pic_clause) {
  if (pic_clause != nullptr) {
    
  } else {
    
  }
  _impl_.pic_clause_.SetAllocated(pic_clause, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pic_clause_.IsDefault()) {
    _impl_.pic_clause_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.FieldDescriptor.pic_clause)
}

// string type = 4;
inline void FieldDescriptor::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& FieldDescriptor::type() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldDescriptor::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.type)
}
inline std::string* FieldDescriptor::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:copybook.transport.FieldDescriptor.type)
  return _s;
}
inline const std::string& FieldDescriptor::_internal_type() const {
  return _impl_.type_.Get();
}
inline void FieldDescriptor::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldDescriptor::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldDescriptor::release_type() {
  // @@protoc_insertion_point(field_release:copybook.transport.FieldDescriptor.type)
  return _impl_.type_.Release();
}
inline void FieldDescriptor::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.FieldDescriptor.type)
}

// int32 offset = 5;
inline void FieldDescriptor::clear_offset() {
  _impl_.offset_ = 0;
}
inline int32_t FieldDescriptor::_internal_offset() const {
  return _impl_.offset_;
}
inline int32_t FieldDescriptor::offset() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.offset)
  return _internal_offset();
}
inline void FieldDescriptor::_internal_set_offset(int32_t value) {
  
  _impl_.offset_ = value;
}
inline void FieldDescriptor::set_offset(int32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.offset)
}

// int32 size = 6;
inline void FieldDescriptor::clear_size() {
  _impl_.size_ = 0;
}
inline int32_t FieldDescriptor::_internal_size() const {
  return _impl_.size_;
}
inline int32_t FieldDescriptor::size() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.size)
  return _internal_size();
}
inline void FieldDescriptor::_internal_set_size(int32_t value) {
  
  _impl_.size_ = value;
}
inline void FieldDescriptor::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.size)
}

// int32 decimal_positions = 7;
inline void FieldDescriptor::clear_decimal_positions() {
  _impl_.decimal_positions_ = 0;
}
inline int32_t FieldDescriptor::_internal_decimal_positions() const {
  return _impl_.decimal_positions_;
}
inline int32_t FieldDescriptor::decimal_positions() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.decimal_positions)
  return _internal_decimal_positions();
}
inline void FieldDescriptor::_internal_set_decimal_positions(int32_t value) {
  
  _impl_.decimal_positions_ = value;
}
inline void FieldDescriptor::set_decimal_positions(int32_t value) {
  _internal_set_decimal_positions(value);
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.decimal_positions)
}

// bool is_group = 8;
inline void FieldDescriptor::clear_is_group() {
  _impl_.is_group_ = false;
}
inline bool FieldDescriptor::_internal_is_group() const {
  return _impl_.is_group_;
}
inline bool FieldDescriptor::is_group() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.is_group)
  return _internal_is_group();
}
inline void FieldDescriptor::_internal_set_is_group(bool value) {
  
  _impl_.is_group_ = value;
}
inline void FieldDescriptor::set_is_group(bool value) {
  _internal_set_is_group(value);
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.is_group)
}

// bool is_filler = 9;
inline void FieldDescriptor::clear_is_filler() {
  _impl_.is_filler_ = false;
}
inline bool FieldDescriptor::_internal_is_filler() const {
  return _impl_.is_filler_;
}
inline bool FieldDescriptor::is_filler() const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.is_filler)
  return _internal_is_filler();
}
inline void FieldDescriptor::_internal_set_is_filler(bool value) {
  
  _impl_.is_filler_ = value;
}
inline void FieldDescriptor::set_is_filler(bool value) {
  _internal_set_is_filler(value);
  // @@protoc_insertion_point(field_set:copybook.transport.FieldDescriptor.is_filler)
}

// repeated .copybook.transport.FieldDescriptor children = 10;
inline int FieldDescriptor::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int FieldDescriptor::children_size() const {
  return _internal_children_size();
}
inline void FieldDescriptor::clear_children() {
  _impl_.children_.Clear();
}
inline ::copybook::transport::FieldDescriptor* FieldDescriptor::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:copybook.transport.FieldDescriptor.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor >*
FieldDescriptor::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:copybook.transport.FieldDescriptor.children)
  return &_impl_.children_;
}
inline const ::copybook::transport::FieldDescriptor& FieldDescriptor::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::copybook::transport::FieldDescriptor& FieldDescriptor::children(int index) const {
  // @@protoc_insertion_point(field_get:copybook.transport.FieldDescriptor.children)
  return _internal_children(index);
}
inline ::copybook::transport::FieldDescriptor* FieldDescriptor::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::copybook::transport::FieldDescriptor* FieldDescriptor::add_children() {
  ::copybook::transport::FieldDescriptor* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:copybook.transport.FieldDescriptor.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor >&
FieldDescriptor::children() const {
  // @@protoc_insertion_point(field_list:copybook.transport.FieldDescriptor.children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// RecordSchema

// string record_name = 1;
inline void RecordSchema::clear_record_name() {
  _impl_.record_name_.ClearToEmpty();
}
inline const std::string& RecordSchema::record_name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordSchema.record_name)
  return _internal_record_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordSchema::set_record_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.record_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.RecordSchema.record_name)
}
inline std::string* RecordSchema::mutable_record_name() {
  std::string* _s = _internal_mutable_record_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.RecordSchema.record_name)
  return _s;
}
inline const std::string& RecordSchema::_internal_record_name() const {
  return _impl_.record_name_.Get();
}
inline void RecordSchema::_internal_set_record_name(const std::string& value) {
  
  _impl_.record_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordSchema::_internal_mutable_record_name() {
  
  return _impl_.record_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordSchema::release_record_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.RecordSchema.record_name)
  return _impl_.record_name_.Release();
}
inline void RecordSchema::set_allocated_record_name(std::string* record_name) {
  if (record_name != nullptr) {
    
  } else {
    
  }
  _impl_.record_name_.SetAllocated(record_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.record_name_.IsDefault()) {
    _impl_.record_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.RecordSchema.record_name)
}

// string cpp_class_name = 2;
inline void RecordSchema::clear_cpp_class_name() {
  _impl_.cpp_class_name_.ClearToEmpty();
}
inline const std::string& RecordSchema::cpp_class_name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordSchema.cpp_class_name)
  return _internal_cpp_class_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecordSchema::set_cpp_class_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cpp_class_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.RecordSchema.cpp_class_name)
}
inline std::string* RecordSchema::mutable_cpp_class_name() {
  std::string* _s = _internal_mutable_cpp_class_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.RecordSchema.cpp_class_name)
  return _s;
}
inline const std::string& RecordSchema::_internal_cpp_class_name() const {
  return _impl_.cpp_class_name_.Get();
}
inline void RecordSchema::_internal_set_cpp_class_name(const std::string& value) {
  
  _impl_.cpp_class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecordSchema::_internal_mutable_cpp_class_name() {
  
  return _impl_.cpp_class_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecordSchema::release_cpp_class_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.RecordSchema.cpp_class_name)
  return _impl_.cpp_class_name_.Release();
}
inline void RecordSchema::set_allocated_cpp_class_name(std::string* cpp_class_name) {
  if (cpp_class_name != nullptr) {
    
  } else {
    
  }
  _impl_.cpp_class_name_.SetAllocated(cpp_class_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cpp_class_name_.IsDefault()) {
    _impl_.cpp_class_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.RecordSchema.cpp_class_name)
}

// int32 total_size = 3;
inline void RecordSchema::clear_total_size() {
  _impl_.total_size_ = 0;
}
inline int32_t RecordSchema::_internal_total_size() const {
  return _impl_.total_size_;
}
inline int32_t RecordSchema::total_size() const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordSchema.total_size)
  return _internal_total_size();
}
inline void RecordSchema::_internal_set_total_size(int32_t value) {
  
  _impl_.total_size_ = value;
}
inline void RecordSchema::set_total_size(int32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:copybook.transport.RecordSchema.total_size)
}

// repeated .copybook.transport.FieldDescriptor fields = 4;
inline int RecordSchema::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int RecordSchema::fields_size() const {
  return _internal_fields_size();
}
inline void RecordSchema::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::copybook::transport::FieldDescriptor* RecordSchema::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:copybook.transport.RecordSchema.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor >*
RecordSchema::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:copybook.transport.RecordSchema.fields)
  return &_impl_.fields_;
}
inline const ::copybook::transport::FieldDescriptor& RecordSchema::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::copybook::transport::FieldDescriptor& RecordSchema::fields(int index) const {
  // @@protoc_insertion_point(field_get:copybook.transport.RecordSchema.fields)
  return _internal_fields(index);
}
inline ::copybook::transport::FieldDescriptor* RecordSchema::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::copybook::transport::FieldDescriptor* RecordSchema::add_fields() {
  ::copybook::transport::FieldDescriptor* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:copybook.transport.RecordSchema.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::FieldDescriptor >&
RecordSchema::fields() const {
  // @@protoc_insertion_point(field_list:copybook.transport.RecordSchema.fields)
  return _impl_.fields_;
}

// -------------------------------------------------------------------

// SendRequest

// .copybook.transport.RecordPayload payload = 1;
inline bool SendRequest::_internal_has_payload() const {
  return this != internal_default_instance() && _impl_.payload_ != nullptr;
}
inline bool SendRequest::has_payload() const {
  return _internal_has_payload();
}
inline void SendRequest::clear_payload() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_ != nullptr) {
    delete _impl_.payload_;
  }
  _impl_.payload_ = nullptr;
}
inline const ::copybook::transport::RecordPayload& SendRequest::_internal_payload() const {
  const ::copybook::transport::RecordPayload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::copybook::transport::RecordPayload&>(
      ::copybook::transport::_RecordPayload_default_instance_);
}
inline const ::copybook::transport::RecordPayload& SendRequest::payload() const {
  // @@protoc_insertion_point(field_get:copybook.transport.SendRequest.payload)
  return _internal_payload();
}
inline void SendRequest::unsafe_arena_set_allocated_payload(
    ::copybook::transport::RecordPayload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:copybook.transport.SendRequest.payload)
}
inline ::copybook::transport::RecordPayload* SendRequest::release_payload() {
  
  ::copybook::transport::RecordPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::copybook::transport::RecordPayload* SendRequest::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:copybook.transport.SendRequest.payload)
  
  ::copybook::transport::RecordPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::copybook::transport::RecordPayload* SendRequest::_internal_mutable_payload() {
  
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::copybook::transport::RecordPayload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::copybook::transport::RecordPayload* SendRequest::mutable_payload() {
  ::copybook::transport::RecordPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:copybook.transport.SendRequest.payload)
  return _msg;
}
inline void SendRequest::set_allocated_payload(::copybook::transport::RecordPayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.SendRequest.payload)
}

// -------------------------------------------------------------------

// SendResponse

// bool success = 1;
inline void SendResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool SendResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SendResponse::success() const {
  // @@protoc_insertion_point(field_get:copybook.transport.SendResponse.success)
  return _internal_success();
}
inline void SendResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SendResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:copybook.transport.SendResponse.success)
}

// string message = 2;
inline void SendResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SendResponse::message() const {
  // @@protoc_insertion_point(field_get:copybook.transport.SendResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.SendResponse.message)
}
inline std::string* SendResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:copybook.transport.SendResponse.message)
  return _s;
}
inline const std::string& SendResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SendResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SendResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SendResponse::release_message() {
  // @@protoc_insertion_point(field_release:copybook.transport.SendResponse.message)
  return _impl_.message_.Release();
}
inline void SendResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.SendResponse.message)
}

// -------------------------------------------------------------------

// GetFieldsRequest

// .copybook.transport.RecordPayload payload = 1;
inline bool GetFieldsRequest::_internal_has_payload() const {
  return this != internal_default_instance() && _impl_.payload_ != nullptr;
}
inline bool GetFieldsRequest::has_payload() const {
  return _internal_has_payload();
}
inline void GetFieldsRequest::clear_payload() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_ != nullptr) {
    delete _impl_.payload_;
  }
  _impl_.payload_ = nullptr;
}
inline const ::copybook::transport::RecordPayload& GetFieldsRequest::_internal_payload() const {
  const ::copybook::transport::RecordPayload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::copybook::transport::RecordPayload&>(
      ::copybook::transport::_RecordPayload_default_instance_);
}
inline const ::copybook::transport::RecordPayload& GetFieldsRequest::payload() const {
  // @@protoc_insertion_point(field_get:copybook.transport.GetFieldsRequest.payload)
  return _internal_payload();
}
inline void GetFieldsRequest::unsafe_arena_set_allocated_payload(
    ::copybook::transport::RecordPayload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:copybook.transport.GetFieldsRequest.payload)
}
inline ::copybook::transport::RecordPayload* GetFieldsRequest::release_payload() {
  
  ::copybook::transport::RecordPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::copybook::transport::RecordPayload* GetFieldsRequest::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:copybook.transport.GetFieldsRequest.payload)
  
  ::copybook::transport::RecordPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::copybook::transport::RecordPayload* GetFieldsRequest::_internal_mutable_payload() {
  
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::copybook::transport::RecordPayload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::copybook::transport::RecordPayload* GetFieldsRequest::mutable_payload() {
  ::copybook::transport::RecordPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:copybook.transport.GetFieldsRequest.payload)
  return _msg;
}
inline void GetFieldsRequest::set_allocated_payload(::copybook::transport::RecordPayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.GetFieldsRequest.payload)
}

// -------------------------------------------------------------------

// GetFieldsResponse

// .copybook.transport.RecordMessage record = 1;
inline bool GetFieldsResponse::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool GetFieldsResponse::has_record() const {
  return _internal_has_record();
}
inline void GetFieldsResponse::clear_record() {
  if (GetArenaForAllocation() == nullptr && _impl_.record_ != nullptr) {
    delete _impl_.record_;
  }
  _impl_.record_ = nullptr;
}
inline const ::copybook::transport::RecordMessage& GetFieldsResponse::_internal_record() const {
  const ::copybook::transport::RecordMessage* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::copybook::transport::RecordMessage&>(
      ::copybook::transport::_RecordMessage_default_instance_);
}
inline const ::copybook::transport::RecordMessage& GetFieldsResponse::record() const {
  // @@protoc_insertion_point(field_get:copybook.transport.GetFieldsResponse.record)
  return _internal_record();
}
inline void GetFieldsResponse::unsafe_arena_set_allocated_record(
    ::copybook::transport::RecordMessage* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:copybook.transport.GetFieldsResponse.record)
}
inline ::copybook::transport::RecordMessage* GetFieldsResponse::release_record() {
  
  ::copybook::transport::RecordMessage* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::copybook::transport::RecordMessage* GetFieldsResponse::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:copybook.transport.GetFieldsResponse.record)
  
  ::copybook::transport::RecordMessage* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::copybook::transport::RecordMessage* GetFieldsResponse::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::copybook::transport::RecordMessage>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::copybook::transport::RecordMessage* GetFieldsResponse::mutable_record() {
  ::copybook::transport::RecordMessage* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:copybook.transport.GetFieldsResponse.record)
  return _msg;
}
inline void GetFieldsResponse::set_allocated_record(::copybook::transport::RecordMessage* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.GetFieldsResponse.record)
}

// -------------------------------------------------------------------

// SetFieldsRequest

// .copybook.transport.RecordMessage record = 1;
inline bool SetFieldsRequest::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool SetFieldsRequest::has_record() const {
  return _internal_has_record();
}
inline void SetFieldsRequest::clear_record() {
  if (GetArenaForAllocation() == nullptr && _impl_.record_ != nullptr) {
    delete _impl_.record_;
  }
  _impl_.record_ = nullptr;
}
inline const ::copybook::transport::RecordMessage& SetFieldsRequest::_internal_record() const {
  const ::copybook::transport::RecordMessage* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::copybook::transport::RecordMessage&>(
      ::copybook::transport::_RecordMessage_default_instance_);
}
inline const ::copybook::transport::RecordMessage& SetFieldsRequest::record() const {
  // @@protoc_insertion_point(field_get:copybook.transport.SetFieldsRequest.record)
  return _internal_record();
}
inline void SetFieldsRequest::unsafe_arena_set_allocated_record(
    ::copybook::transport::RecordMessage* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:copybook.transport.SetFieldsRequest.record)
}
inline ::copybook::transport::RecordMessage* SetFieldsRequest::release_record() {
  
  ::copybook::transport::RecordMessage* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::copybook::transport::RecordMessage* SetFieldsRequest::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:copybook.transport.SetFieldsRequest.record)
  
  ::copybook::transport::RecordMessage* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::copybook::transport::RecordMessage* SetFieldsRequest::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::copybook::transport::RecordMessage>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::copybook::transport::RecordMessage* SetFieldsRequest::mutable_record() {
  ::copybook::transport::RecordMessage* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:copybook.transport.SetFieldsRequest.record)
  return _msg;
}
inline void SetFieldsRequest::set_allocated_record(::copybook::transport::RecordMessage* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.SetFieldsRequest.record)
}

// int32 buffer_size = 2;
inline void SetFieldsRequest::clear_buffer_size() {
  _impl_.buffer_size_ = 0;
}
inline int32_t SetFieldsRequest::_internal_buffer_size() const {
  return _impl_.buffer_size_;
}
inline int32_t SetFieldsRequest::buffer_size() const {
  // @@protoc_insertion_point(field_get:copybook.transport.SetFieldsRequest.buffer_size)
  return _internal_buffer_size();
}
inline void SetFieldsRequest::_internal_set_buffer_size(int32_t value) {
  
  _impl_.buffer_size_ = value;
}
inline void SetFieldsRequest::set_buffer_size(int32_t value) {
  _internal_set_buffer_size(value);
  // @@protoc_insertion_point(field_set:copybook.transport.SetFieldsRequest.buffer_size)
}

// -------------------------------------------------------------------

// SetFieldsResponse

// .copybook.transport.RecordPayload payload = 1;
inline bool SetFieldsResponse::_internal_has_payload() const {
  return this != internal_default_instance() && _impl_.payload_ != nullptr;
}
inline bool SetFieldsResponse::has_payload() const {
  return _internal_has_payload();
}
inline void SetFieldsResponse::clear_payload() {
  if (GetArenaForAllocation() == nullptr && _impl_.payload_ != nullptr) {
    delete _impl_.payload_;
  }
  _impl_.payload_ = nullptr;
}
inline const ::copybook::transport::RecordPayload& SetFieldsResponse::_internal_payload() const {
  const ::copybook::transport::RecordPayload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::copybook::transport::RecordPayload&>(
      ::copybook::transport::_RecordPayload_default_instance_);
}
inline const ::copybook::transport::RecordPayload& SetFieldsResponse::payload() const {
  // @@protoc_insertion_point(field_get:copybook.transport.SetFieldsResponse.payload)
  return _internal_payload();
}
inline void SetFieldsResponse::unsafe_arena_set_allocated_payload(
    ::copybook::transport::RecordPayload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:copybook.transport.SetFieldsResponse.payload)
}
inline ::copybook::transport::RecordPayload* SetFieldsResponse::release_payload() {
  
  ::copybook::transport::RecordPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::copybook::transport::RecordPayload* SetFieldsResponse::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:copybook.transport.SetFieldsResponse.payload)
  
  ::copybook::transport::RecordPayload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::copybook::transport::RecordPayload* SetFieldsResponse::_internal_mutable_payload() {
  
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::copybook::transport::RecordPayload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::copybook::transport::RecordPayload* SetFieldsResponse::mutable_payload() {
  ::copybook::transport::RecordPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:copybook.transport.SetFieldsResponse.payload)
  return _msg;
}
inline void SetFieldsResponse::set_allocated_payload(::copybook::transport::RecordPayload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.SetFieldsResponse.payload)
}

// -------------------------------------------------------------------

// SchemaRequest

// string record_name = 1;
inline void SchemaRequest::clear_record_name() {
  _impl_.record_name_.ClearToEmpty();
}
inline const std::string& SchemaRequest::record_name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.SchemaRequest.record_name)
  return _internal_record_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaRequest::set_record_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.record_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.SchemaRequest.record_name)
}
inline std::string* SchemaRequest::mutable_record_name() {
  std::string* _s = _internal_mutable_record_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.SchemaRequest.record_name)
  return _s;
}
inline const std::string& SchemaRequest::_internal_record_name() const {
  return _impl_.record_name_.Get();
}
inline void SchemaRequest::_internal_set_record_name(const std::string& value) {
  
  _impl_.record_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaRequest::_internal_mutable_record_name() {
  
  return _impl_.record_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SchemaRequest::release_record_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.SchemaRequest.record_name)
  return _impl_.record_name_.Release();
}
inline void SchemaRequest::set_allocated_record_name(std::string* record_name) {
  if (record_name != nullptr) {
    
  } else {
    
  }
  _impl_.record_name_.SetAllocated(record_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.record_name_.IsDefault()) {
    _impl_.record_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.SchemaRequest.record_name)
}

// -------------------------------------------------------------------

// SchemaResponse

// .copybook.transport.RecordSchema schema = 1;
inline bool SchemaResponse::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool SchemaResponse::has_schema() const {
  return _internal_has_schema();
}
inline void SchemaResponse::clear_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
}
inline const ::copybook::transport::RecordSchema& SchemaResponse::_internal_schema() const {
  const ::copybook::transport::RecordSchema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::copybook::transport::RecordSchema&>(
      ::copybook::transport::_RecordSchema_default_instance_);
}
inline const ::copybook::transport::RecordSchema& SchemaResponse::schema() const {
  // @@protoc_insertion_point(field_get:copybook.transport.SchemaResponse.schema)
  return _internal_schema();
}
inline void SchemaResponse::unsafe_arena_set_allocated_schema(
    ::copybook::transport::RecordSchema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:copybook.transport.SchemaResponse.schema)
}
inline ::copybook::transport::RecordSchema* SchemaResponse::release_schema() {
  
  ::copybook::transport::RecordSchema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::copybook::transport::RecordSchema* SchemaResponse::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:copybook.transport.SchemaResponse.schema)
  
  ::copybook::transport::RecordSchema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::copybook::transport::RecordSchema* SchemaResponse::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::copybook::transport::RecordSchema>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::copybook::transport::RecordSchema* SchemaResponse::mutable_schema() {
  ::copybook::transport::RecordSchema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:copybook.transport.SchemaResponse.schema)
  return _msg;
}
inline void SchemaResponse::set_allocated_schema(::copybook::transport::RecordSchema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.SchemaResponse.schema)
}

// -------------------------------------------------------------------

// ListSchemasRequest

// -------------------------------------------------------------------

// ListSchemasResponse

// repeated .copybook.transport.RecordSchema schemas = 1;
inline int ListSchemasResponse::_internal_schemas_size() const {
  return _impl_.schemas_.size();
}
inline int ListSchemasResponse::schemas_size() const {
  return _internal_schemas_size();
}
inline void ListSchemasResponse::clear_schemas() {
  _impl_.schemas_.Clear();
}
inline ::copybook::transport::RecordSchema* ListSchemasResponse::mutable_schemas(int index) {
  // @@protoc_insertion_point(field_mutable:copybook.transport.ListSchemasResponse.schemas)
  return _impl_.schemas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::RecordSchema >*
ListSchemasResponse::mutable_schemas() {
  // @@protoc_insertion_point(field_mutable_list:copybook.transport.ListSchemasResponse.schemas)
  return &_impl_.schemas_;
}
inline const ::copybook::transport::RecordSchema& ListSchemasResponse::_internal_schemas(int index) const {
  return _impl_.schemas_.Get(index);
}
inline const ::copybook::transport::RecordSchema& ListSchemasResponse::schemas(int index) const {
  // @@protoc_insertion_point(field_get:copybook.transport.ListSchemasResponse.schemas)
  return _internal_schemas(index);
}
inline ::copybook::transport::RecordSchema* ListSchemasResponse::_internal_add_schemas() {
  return _impl_.schemas_.Add();
}
inline ::copybook::transport::RecordSchema* ListSchemasResponse::add_schemas() {
  ::copybook::transport::RecordSchema* _add = _internal_add_schemas();
  // @@protoc_insertion_point(field_add:copybook.transport.ListSchemasResponse.schemas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::copybook::transport::RecordSchema >&
ListSchemasResponse::schemas() const {
  // @@protoc_insertion_point(field_list:copybook.transport.ListSchemasResponse.schemas)
  return _impl_.schemas_;
}

// -------------------------------------------------------------------

// ConvertRequest

// string format = 1;
inline void ConvertRequest::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& ConvertRequest::format() const {
  // @@protoc_insertion_point(field_get:copybook.transport.ConvertRequest.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConvertRequest::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.ConvertRequest.format)
}
inline std::string* ConvertRequest::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:copybook.transport.ConvertRequest.format)
  return _s;
}
inline const std::string& ConvertRequest::_internal_format() const {
  return _impl_.format_.Get();
}
inline void ConvertRequest::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* ConvertRequest::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* ConvertRequest::release_format() {
  // @@protoc_insertion_point(field_release:copybook.transport.ConvertRequest.format)
  return _impl_.format_.Release();
}
inline void ConvertRequest::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.ConvertRequest.format)
}

// .copybook.transport.RecordPayload payload = 2;
inline bool ConvertRequest::_internal_has_payload() const {
  return source_case() == kPayload;
}
inline bool ConvertRequest::has_payload() const {
  return _internal_has_payload();
}
inline void ConvertRequest::set_has_payload() {
  _impl_._oneof_case_[0] = kPayload;
}
inline void ConvertRequest::clear_payload() {
  if (_internal_has_payload()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.source_.payload_;
    }
    clear_has_source();
  }
}
inline ::copybook::transport::RecordPayload* ConvertRequest::release_payload() {
  // @@protoc_insertion_point(field_release:copybook.transport.ConvertRequest.payload)
  if (_internal_has_payload()) {
    clear_has_source();
    ::copybook::transport::RecordPayload* temp = _impl_.source_.payload_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_.payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::copybook::transport::RecordPayload& ConvertRequest::_internal_payload() const {
  return _internal_has_payload()
      ? *_impl_.source_.payload_
      : reinterpret_cast< ::copybook::transport::RecordPayload&>(::copybook::transport::_RecordPayload_default_instance_);
}
inline const ::copybook::transport::RecordPayload& ConvertRequest::payload() const {
  // @@protoc_insertion_point(field_get:copybook.transport.ConvertRequest.payload)
  return _internal_payload();
}
inline ::copybook::transport::RecordPayload* ConvertRequest::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:copybook.transport.ConvertRequest.payload)
  if (_internal_has_payload()) {
    clear_has_source();
    ::copybook::transport::RecordPayload* temp = _impl_.source_.payload_;
    _impl_.source_.payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConvertRequest::unsafe_arena_set_allocated_payload(::copybook::transport::RecordPayload* payload) {
  clear_source();
  if (payload) {
    set_has_payload();
    _impl_.source_.payload_ = payload;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:copybook.transport.ConvertRequest.payload)
}
inline ::copybook::transport::RecordPayload* ConvertRequest::_internal_mutable_payload() {
  if (!_internal_has_payload()) {
    clear_source();
    set_has_payload();
    _impl_.source_.payload_ = CreateMaybeMessage< ::copybook::transport::RecordPayload >(GetArenaForAllocation());
  }
  return _impl_.source_.payload_;
}
inline ::copybook::transport::RecordPayload* ConvertRequest::mutable_payload() {
  ::copybook::transport::RecordPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:copybook.transport.ConvertRequest.payload)
  return _msg;
}

// string format_data = 3;
inline bool ConvertRequest::_internal_has_format_data() const {
  return source_case() == kFormatData;
}
inline bool ConvertRequest::has_format_data() const {
  return _internal_has_format_data();
}
inline void ConvertRequest::set_has_format_data() {
  _impl_._oneof_case_[0] = kFormatData;
}
inline void ConvertRequest::clear_format_data() {
  if (_internal_has_format_data()) {
    _impl_.source_.format_data_.Destroy();
    clear_has_source();
  }
}
inline const std::string& ConvertRequest::format_data() const {
  // @@protoc_insertion_point(field_get:copybook.transport.ConvertRequest.format_data)
  return _internal_format_data();
}
template <typename ArgT0, typename... ArgT>
inline void ConvertRequest::set_format_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_format_data()) {
    clear_source();
    set_has_format_data();
    _impl_.source_.format_data_.InitDefault();
  }
  _impl_.source_.format_data_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.ConvertRequest.format_data)
}
inline std::string* ConvertRequest::mutable_format_data() {
  std::string* _s = _internal_mutable_format_data();
  // @@protoc_insertion_point(field_mutable:copybook.transport.ConvertRequest.format_data)
  return _s;
}
inline const std::string& ConvertRequest::_internal_format_data() const {
  if (_internal_has_format_data()) {
    return _impl_.source_.format_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ConvertRequest::_internal_set_format_data(const std::string& value) {
  if (!_internal_has_format_data()) {
    clear_source();
    set_has_format_data();
    _impl_.source_.format_data_.InitDefault();
  }
  _impl_.source_.format_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ConvertRequest::_internal_mutable_format_data() {
  if (!_internal_has_format_data()) {
    clear_source();
    set_has_format_data();
    _impl_.source_.format_data_.InitDefault();
  }
  return _impl_.source_.format_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* ConvertRequest::release_format_data() {
  // @@protoc_insertion_point(field_release:copybook.transport.ConvertRequest.format_data)
  if (_internal_has_format_data()) {
    clear_has_source();
    return _impl_.source_.format_data_.Release();
  } else {
    return nullptr;
  }
}
inline void ConvertRequest::set_allocated_format_data(std::string* format_data) {
  if (has_source()) {
    clear_source();
  }
  if (format_data != nullptr) {
    set_has_format_data();
    _impl_.source_.format_data_.InitAllocated(format_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.ConvertRequest.format_data)
}

// string record_name = 4;
inline void ConvertRequest::clear_record_name() {
  _impl_.record_name_.ClearToEmpty();
}
inline const std::string& ConvertRequest::record_name() const {
  // @@protoc_insertion_point(field_get:copybook.transport.ConvertRequest.record_name)
  return _internal_record_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConvertRequest::set_record_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.record_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.ConvertRequest.record_name)
}
inline std::string* ConvertRequest::mutable_record_name() {
  std::string* _s = _internal_mutable_record_name();
  // @@protoc_insertion_point(field_mutable:copybook.transport.ConvertRequest.record_name)
  return _s;
}
inline const std::string& ConvertRequest::_internal_record_name() const {
  return _impl_.record_name_.Get();
}
inline void ConvertRequest::_internal_set_record_name(const std::string& value) {
  
  _impl_.record_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConvertRequest::_internal_mutable_record_name() {
  
  return _impl_.record_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConvertRequest::release_record_name() {
  // @@protoc_insertion_point(field_release:copybook.transport.ConvertRequest.record_name)
  return _impl_.record_name_.Release();
}
inline void ConvertRequest::set_allocated_record_name(std::string* record_name) {
  if (record_name != nullptr) {
    
  } else {
    
  }
  _impl_.record_name_.SetAllocated(record_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.record_name_.IsDefault()) {
    _impl_.record_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.ConvertRequest.record_name)
}

inline bool ConvertRequest::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void ConvertRequest::clear_has_source() {
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}
inline ConvertRequest::SourceCase ConvertRequest::source_case() const {
  return ConvertRequest::SourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConvertResponse

// string format_data = 1;
inline bool ConvertResponse::_internal_has_format_data() const {
  return result_case() == kFormatData;
}
inline bool ConvertResponse::has_format_data() const {
  return _internal_has_format_data();
}
inline void ConvertResponse::set_has_format_data() {
  _impl_._oneof_case_[0] = kFormatData;
}
inline void ConvertResponse::clear_format_data() {
  if (_internal_has_format_data()) {
    _impl_.result_.format_data_.Destroy();
    clear_has_result();
  }
}
inline const std::string& ConvertResponse::format_data() const {
  // @@protoc_insertion_point(field_get:copybook.transport.ConvertResponse.format_data)
  return _internal_format_data();
}
template <typename ArgT0, typename... ArgT>
inline void ConvertResponse::set_format_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_format_data()) {
    clear_result();
    set_has_format_data();
    _impl_.result_.format_data_.InitDefault();
  }
  _impl_.result_.format_data_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:copybook.transport.ConvertResponse.format_data)
}
inline std::string* ConvertResponse::mutable_format_data() {
  std::string* _s = _internal_mutable_format_data();
  // @@protoc_insertion_point(field_mutable:copybook.transport.ConvertResponse.format_data)
  return _s;
}
inline const std::string& ConvertResponse::_internal_format_data() const {
  if (_internal_has_format_data()) {
    return _impl_.result_.format_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ConvertResponse::_internal_set_format_data(const std::string& value) {
  if (!_internal_has_format_data()) {
    clear_result();
    set_has_format_data();
    _impl_.result_.format_data_.InitDefault();
  }
  _impl_.result_.format_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ConvertResponse::_internal_mutable_format_data() {
  if (!_internal_has_format_data()) {
    clear_result();
    set_has_format_data();
    _impl_.result_.format_data_.InitDefault();
  }
  return _impl_.result_.format_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* ConvertResponse::release_format_data() {
  // @@protoc_insertion_point(field_release:copybook.transport.ConvertResponse.format_data)
  if (_internal_has_format_data()) {
    clear_has_result();
    return _impl_.result_.format_data_.Release();
  } else {
    return nullptr;
  }
}
inline void ConvertResponse::set_allocated_format_data(std::string* format_data) {
  if (has_result()) {
    clear_result();
  }
  if (format_data != nullptr) {
    set_has_format_data();
    _impl_.result_.format_data_.InitAllocated(format_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:copybook.transport.ConvertResponse.format_data)
}

// .copybook.transport.RecordPayload payload = 2;
inline bool ConvertResponse::_internal_has_payload() const {
  return result_case() == kPayload;
}
inline bool ConvertResponse::has_payload() const {
  return _internal_has_payload();
}
inline void ConvertResponse::set_has_payload() {
  _impl_._oneof_case_[0] = kPayload;
}
inline void ConvertResponse::clear_payload() {
  if (_internal_has_payload()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.payload_;
    }
    clear_has_result();
  }
}
inline ::copybook::transport::RecordPayload* ConvertResponse::release_payload() {
  // @@protoc_insertion_point(field_release:copybook.transport.ConvertResponse.payload)
  if (_internal_has_payload()) {
    clear_has_result();
    ::copybook::transport::RecordPayload* temp = _impl_.result_.payload_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::copybook::transport::RecordPayload& ConvertResponse::_internal_payload() const {
  return _internal_has_payload()
      ? *_impl_.result_.payload_
      : reinterpret_cast< ::copybook::transport::RecordPayload&>(::copybook::transport::_RecordPayload_default_instance_);
}
inline const ::copybook::transport::RecordPayload& ConvertResponse::payload() const {
  // @@protoc_insertion_point(field_get:copybook.transport.ConvertResponse.payload)
  return _internal_payload();
}
inline ::copybook::transport::RecordPayload* ConvertResponse::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:copybook.transport.ConvertResponse.payload)
  if (_internal_has_payload()) {
    clear_has_result();
    ::copybook::transport::RecordPayload* temp = _impl_.result_.payload_;
    _impl_.result_.payload_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConvertResponse::unsafe_arena_set_allocated_payload(::copybook::transport::RecordPayload* payload) {
  clear_result();
  if (payload) {
    set_has_payload();
    _impl_.result_.payload_ = payload;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:copybook.transport.ConvertResponse.payload)
}
inline ::copybook::transport::RecordPayload* ConvertResponse::_internal_mutable_payload() {
  if (!_internal_has_payload()) {
    clear_result();
    set_has_payload();
    _impl_.result_.payload_ = CreateMaybeMessage< ::copybook::transport::RecordPayload >(GetArenaForAllocation());
  }
  return _impl_.result_.payload_;
}
inline ::copybook::transport::RecordPayload* ConvertResponse::mutable_payload() {
  ::copybook::transport::RecordPayload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:copybook.transport.ConvertResponse.payload)
  return _msg;
}

inline bool ConvertResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void ConvertResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline ConvertResponse::ResultCase ConvertResponse::result_case() const {
  return ConvertResponse::ResultCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace transport
}  // namespace copybook

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_copybook_5fservice_2eproto
